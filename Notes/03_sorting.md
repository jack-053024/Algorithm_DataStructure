[TOC]

# 与排序算法的相爱相杀

## 一、排序（上）：为什么插入排序比冒泡排序更好

### 1.1 如何分析一个排序算法

1. 执行效率

   * 最好、最坏、平均时间复杂度

     对于一个排序算法，我们需要分别分析其**最好、最坏和平均时间复杂度**。并且要知道其**最好、最坏时间复杂度**对应的数据是怎样的。因为**对于不同类型的数据，选用不同排序算法，效率会不一样**，例如有些数据接近有序，有些近乎无序。

   * 时间复杂度的系数、低阶、常数

     虽然当数据量十分巨大的时候，大O表示法便可以粗略决定一个算法的效率，但是对于一些小规模的数据，如果要将性能做到极致，还是需要考虑时间复杂度的系数、低阶以及常数阶的。

   * 数据的比较次数和交换（移动）次数

     数据的比较的交换也需要考虑是因为对于不同的排序算法，对数据的操作可能是一次，有些则需要多次。例如冒泡排序与插入排序的对比，冒泡需要三次，而插入只需要一次。

2. 内存消耗

   即空间复杂度，空间复杂度为 `O(1)` 的排序算法称为**原地排序**

3. 稳定性

   * 概念

     如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变，则为稳定，否则为不稳定。

   * 应用（例子）

     订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？

     最先想到的方法是：我们先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会很复杂。借助稳定排序算法，这个问题可以非常简洁地解决。

     解决思路是这样的：我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。

     ![img](assets\1381c1f3f7819ae61ab17455ed7f0b59.jpg)

### 1.2 排序算法

#### 冒泡排序（`Bubble Sort`）

冒泡排序只会操作相邻的两个元素，每次冒泡对相邻两个元素进行比较，如果满足大小关系要求，则往后移动一位，如果不满足，则交换位置后再往后移动一位。每一组冒泡操作，都会使得至少一个元素移动到它应该在的位置（最大或最小）。重复 `N` 组，则完成排序。

##### 基本代码

```python
def bubble_sort(alist):
    """bubble sorting"""
    alist_len = len(alist)
    for i in range(alist_len - 1, 0, -1):
        for j in range(i):
            if alist[j] > alist[j + 1]:
                # 交换两数位置，在Python中有更方便更快速的做法，即：
                # alist[j], alist[j + 1] = alist[j + 1], alist[j]
                temp = alist[j]
                alist[j] = alist[j + 1]
                alist[j + 1] = temp
    return alist
```

##### 代码优化

加一个标志位，或者对交换进行计数，如果一组冒泡操作中发生了交换，则标志位为真，或者计数不为 `0`，则继续冒泡，否则，说明一组冒泡中无交换，排序结束，可直接返回结果。

```python
def bubble_sort(alist):
    """bubble sorting"""
    alist_len = len(alist)
    for i in range(alist_len - 1, 0, -1):
        flag = False  # set up a flag
        for j in range(i):
            if alist[j] > alist[j + 1]:
                # 交换两数位置，在Python中有更方便更快速的做法，即：
                # alist[j], alist[j + 1] = alist[j + 1], alist[j]
                temp = alist[j]
                alist[j] = alist[j + 1]
                alist[j + 1] = temp
                flag = True
        if not flag:
            return alsit
    return alist
```

##### 算法分析

1. **原地排序？**

   原地排序。因为只用了常数阶的临时空间，所以它的时间复杂度为 `O(1)`。

2. **稳定性？**

   稳定。在冒泡排序中，只有发生交换时才会改变位置，当相邻元素相等时我们不做交换，就可以保持大小相同的元素的位置不变，所以冒泡排序是稳定的

3. **时间复杂度？**

   当元素为逆序，则全部需要排序，此时为最坏时间复杂度，为 `O(N^2)`；

   当元素都已排好序，为最优时间复杂度，大小为 `O(N)`；

   平均时间复杂度，采用[**有序度**和**逆序度**的思路](E:\MarkdownProjects\Algorithm\Hyperlink\有序度和逆序度.md)分析，可得 `O(N^2)`；

#### 插入排序（`Insortion Sort`）

将数组中的数据分为两个区间，已排序区和未排序区。初始已排序区只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素（**一般是第一个元素**），在已排序区中找到合适的插入位置将其插入，并保证已排序区间数据一直有序（**通过比较和移动**）。重复这个过程，直到未排序区中元素为空，算法结束。

##### 基本代码

```python
alist_len = len(alist)
    for i in range(1, alist_len):
        for j in range(i, 0, -1):
            if alist[j] < alist[j-1]:
                # 直接交换，在Python中，这样的速度也很快。
                alist[j], alist[j-1] = alist[j-1], alist[j]  
            else:
                break
```

##### 代码优化

先用 `temp` 记录待排序的值，然后对比之后，如果需要则直接将值后移，当不需后移时，则将 `temp` 值赋给 `alist[j]`，然后跳出循环。

```python
def insertion_sort(alist):
    """insertion sort"""
    alist_len = len(alist)
    for i in range(1, alist_len):
        temp = alist[i]
        for j in range(i, 0, -1):
            if alist[j - 1] > temp:
                # 元素后移
                alist[j] = alist[j-1]
            else:
                alist[j] = temp
                break
            alist[j-1] = temp  # 需要注意的点。
```

##### 算法分析

1. **原地排序？**

   原地排序。因为只用了常数阶的临时空间，所以它的时间复杂度为 `O(1)`。

2. **稳定性？**

   稳定。在插入排序中，只有发生元素移动（或元素交换）时才会改变位置，当相邻元素相等时我们不做移动（或交换），就可以保持大小相同的元素的位置不变，所以插入排序是稳定的

3. **时间复杂度？**

   当元素为逆序，则全部需要排序，此时为最坏时间复杂度，为 `O(N^2)`；

   当元素都已排好序，为最优时间复杂度，大小为 `O(N)`；

   平均时间复杂度，采用[**有序度**和**逆序度**的思路](E:\MarkdownProjects\Algorithm\Hyperlink\有序度和逆序度.md)分析，可得 `O(N^2)`；

#### 选择排序（Selection Sort）

```python
def selection_sort(alist):
    """选择排序"""
    # 1.分成已排区和未排序区
    # 2.将未排序区中的第一个数假定为最小，并记住它的下标，以此为标识最小数的下标
    # 3.将假定的数与未排序区中的每个数依次比较，如果发现比假定数更小的数，则将标识最小数的下标改为该数下标
    # 4.当遍历完未排序区的数，最终得到的最小数下标，就是本轮找到的最小数
    # 5.把假定的最小数的位置，与真正的最小数的位置进行交换
    # 6.以上循环，直到排序完
    alist_len = len(alist)
    for j in range(0, alist_len-1):
        min_index = j
        for i in range(j+1, alist_len):
            if alist[min_index] > alist[i]:
                min_index = i
        alist[j], alist[min_index] = alist[min_index], alist[j]
```

##### 算法分析

1. **原地排序？**

   原地排序。因为只用了常数阶的临时空间，所以它的时间复杂度为 `O(1)`。

2. **稳定性？**

   不稳定。在选择排序中，发生元素交换时就会改变位置，而如果最小元素在其相等元素的后面，此时发生交换，则元素会改变其先后位置。所以选择排序是不稳定的。

3. **时间复杂度？**

   最好、最坏、平均时间复杂度都为 `O(N^2)`

### 1.3 总结

1. 插入排序比冒泡排序更好。虽然在 `Python` 中，元素的交换时间差不多，所以两者的差异并不明显。但是在其他语言中，冒泡排序的元素交换，需要三次操作，即

   ```python
   temp = alist[j]
   alist[j] = alist[j + 1]
   alist[j + 1] = temp
   ```

   而插入排序可以先用 `temp` 将元素存起，然后只进行元素移动，即 `alist[j] = alist[j-1]`，最后再将 `temp` 赋回，所以只用了一次操作，因此插入排序的效率更高。

2. 选择排序的效率比冒泡排序还要低，且是不稳定的。

3. 插入排序、冒泡排序和选择排序在实际应用中很少见，但是插入排序的思维还是很常用的。

   

## 二、排序（下）：如何用快排思想在O(n)内查找第K大元素

**归并排序、快速排序**

分治思想是一种解决问题的思考方式。递归是一种编程技巧。分治思想一般都会用递归来编写代码。

**归并排序（`Merge Sort`）**基于分治思想，它的时间复杂度都是`O(nlogn)`，看起来非常优秀。但其应用却没有**快排**广，因为归并排序并不是原地排序，其空间复杂度为`O(n)`

**快速排序（`Quick Sort`）**，简称**快排**，也是基于分治思想，用递归实现。快排的最坏时间复杂度是`O(n^2)`，最好时间复杂度为`O(nlogn)`。快排可以利用插入排序时用到的思想，实现原地排序，即`space complexity`为`O(1)`，解决了归并排序占用太多内存空间的问题。

快排是不稳定的。归并排序是稳定的。

### 思考题

* 利用快排思想里的分区在`O(n)`内查找第`K`大元素

  ```python
  def find_target_elem(alist, start, end, K):
      """
      要求在 O(n) 时间复杂度内找出给定的无序数组中的第 K 大元素。
      比如：4, 2, 5, 12, 3这样一组数组里，第 3 大元素为 4。
      Difficulty: easy
      :param alist: 给定的无序数组
      :param start: 操作范围下标起点
      :param end: 操作范围下标终点
      :param K: K 的值
      :return: 返回找到的第 K 大元素
      """
      if start >= end:
          return alist[start]
      mid_val = alist[start]
      low = start                                         #
      high = end
      while low < high:
          while low < high and alist[high] > mid_val:
              high -= 1
          alist[low] = alist[high]
          while low < high and alist[low] < mid_val:
              low += 1
          alist[high] = alist[low]
      alist[low] = mid_val           # 利用快排分区思想，先找到一个数原本应该在的位置
      if low == K - 1:               # 如果该数的位置在 K-1，说明该数就是第 K 大元素
          return alist[low]
      elif low < K - 1:              # 否则，说明在两边，用递归分别调用原函数，并返回
          return find_target_elem(alist, low+1, end, K)
      else:                          # 关键思想：找到了某数位置，前面都比它小，后边都比它大
          return find_target_elem(alist, start, low-1, K)
                                     # time: O(n); space: O(1)
  ```

* 现在你有 `10` 个接口访问日志文件，每个日志文件大小约 `300MB`，每个文件里的日志都是按照时间戳从小到大排序的。你希望将这 `10` 个较小的日志文件，合并为 `1` 个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有`1GB`，你有什么好的解决思路，能“快速”地将这 `10` 个日志文件合并吗？

## 三、线性排序：如何根据年龄给`100`万用户数据排序

这里介绍三种时间复杂度为`O(n)`的排序算法：**桶排序、计数排序和基数排序**。由于其时间复杂度为`O(n)`，因此也叫**线性排序（`Linear Sort`）**，需要注意与之前的排序算法区分：这三种**线性排序不基于元素之间的比较。**

### 3.1 桶排序（`Bucket Sort`）

#### 核心思路

桶排序基于特定的排序场景，例如按照**年龄**来排序。

先将数据扫描一遍，得到最小年龄和最大年龄，再来划分区间，每个区间作为一个桶。再对数据进行扫描，将每个数据归类到对应桶中。然后利用快排对各个桶进行排序，此时各个桶内数据分别有序。由于桶之间天然有序，所以依次从桶中取值后形成的数据集，就是有序数据集。

#### 桶排序分析

假设要排序的数据有 `n` 个，把它们均匀地划分到 `m` 个桶内，每个桶里就有 `k=n/m` 个元素。每个桶内部使用**快速排序**，时间复杂度为 `O(k * logk)`。`m` 个桶排序的时间复杂度就是 `O(m * k * logk)`，因为 `k=n/m`，所以整个桶排序的时间复杂度就是 `O(n*log(n/m))`。当桶的个数 `m` 接近数据个数 `n` 时，`log(n/m)` 就是一个非常小的常量（接近`0`），这个时候桶排序的时间复杂度接近 `O(n)`。

#### 桶排序适用场景

* 要排序的数据需要容易划分成`m`个桶，且范围不能太大
* 数据在各个桶之间的分布是比较均匀的。要是不均匀，即数据较为集中在某个桶中，那使用快排时，时间复杂度会趋向`O(nlogn)`

##### 桶排序比较适用于外部排序

所谓外部排序，就是数据放在磁盘中，数据量大，内存有限，无法将数据全部加载到内存中。

例如，有 `10GB` 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 `MB`，没办法一次性把 `10GB` 的数据都加载到内存中。这个时候该怎么办呢？

利用桶排序，假设数据在桶的分布均匀，则没什么好说的。但实际情况都是不均匀的，这时可以对数据集中的桶再进行一次桶排序。

### 3.2 计数排序（`Counting Sort`）

#### 核心思路&步骤

**计数排序**可以认为是桶排序的一种特殊情况。当要排序的 `n` 个数据的**大小范围并不大**的时候，比如范围是`0-99`，那我们就可以把数据划分为`99 + 1 = 100`个桶，每个桶里的数据值都是相同的，这样可以省去桶内排序的时间。很自然的，因为桶之间天然有大小关系，所以这样子很快就排好了。

##### 步骤

如果要把数据以原数组的形式表现，即转换为`n`个元素有序数组，该这么做呢？**这就涉及到，计数排序中 “计数” 的含义。**我们可以根据下面的步骤来理解：

1. 查找出待排序数组`alist`中元素的大小范围，如`min == 0`，`max == 99`

2. 申请一个**计数数组`count`**，下标范围即`步骤1`中查出的待排序数组大小范围，即`len(count) == 100`

3. 扫描`alist`，计算每个元素的个数，放入`count`。如`alist`中元素`50`的个数有`7`个，则`count[50] = 7`

4. 顺序累加`count`。如`count = [1, 2, 3, 4,..., 100]` ==> `count = [1, 3, 6, 10,..., 5050]`

5. 定义一个临时数组`temp_list`，存放结果，数组大小同`alist`

6. 从后往前，再次遍历`alist`，后续步骤相对复杂，用代码展示。

   ```python
   temp_list = [0] * len(alist)		# 临时数组temp_list，放结果
   for i in range(len(alist), 0, -1):  # 从后往前，保证排序稳定
       val = alist[i-1]		# 从alist中取出一值val，该值对应count的下标
       index = count[val] - 1	# count[val] - 1得到val在temp_list中的位置
       temp_list[index] = val	# 将val放入temp_list
       count[val] -= 1			# 小于等于val的元素个数减一
   ```

#### 计数排序分析

* 计数排序只能用在**数据大小范围不大**的场景中，如果范围`k`比要排序的数据量`n`大得多，那就不适合用计数排序

* 计数排序只能给**非负整数**类型的数据排序，如果是其他类型的数据，要在不改变其相对大小的情况下，转化为非负整数。

  * 比如，考生成绩精确到小数后一位，我们就需要将所有的分数都先乘以 `10`，转化成整数，然后再放到 `9010`个桶内。
  * 比如，要排序的数据中有负数类型，范围是` [-1000, 1000]`，我们就需要先对每个数据都加 `1000`，转化成非负整数。
* 计数排序的时间复杂度为`O(n)`

#### 完整代码

```python
# 假设数组alist满足适用计数排序的原则
def counting_sort(alist):
    """counting sort"""
    alist_len = len(alist)
    if alist_len <= 1:
        return
    max_val = max(alist)				# 获得数组范围 min-max
    count = [0 for x in range(max+1)]	# 定义计数数组 count，大小为 max + 1
    for num in alist:					# 计算每个元素的个数，填入 count 中
        count[num] += 1
    for i in range(1, len(count)):		# 累加 count 中的元素个数
        count[i] = count[i] + count[i-1]
    temp_list = [0] * alist_len			# 定义临时数组，存放排序后的结果
    
    # 算法的关键步骤，有点难理解！！！！
    for i in range(len(alist), 0, -1):  # 从后往前，保证排序稳定性
        val = alist[i-1]		# 从alist中取出一值val，该值对应count的下标
        index = count[val] - 1	# count[val] - 1得到val在temp_list中的位置
        temp_list[index] = val	# 将val放入temp_list
        count[val] -= 1			# 小于等于val的元素个数减一
    
    # 将结果拷贝回原数组alist
    for i in range(alist_len):
        alist[i] = temp_list[i]
```

#### 思考：代码实现时，能否不借助临时数组来存放结果？

不能。如果不借助临时数组，即将遍历到的数填入原数组，此时该数又会重复出现在未遍历区，会被再次遍历。

### 3.3 基数排序（`Radix Sort`）

#### 核心思想

基数排序对数据的要求是**每个数据可以分割出位来比较，并且位之间有递进关系**，例如`a = 2234`和`b = 1234`的比较，由于`a`的高位（千分位）为`2`，`b`的高位为`1`，所以后面的位不用再比较了，直接可以得出结论`a > b` 

#### 假设我们有 10 万个手机号码，如何将这 10 万个手机号码从小到大排序？

##### 分析过程

如果使用快排，最快可达`O(nlogn)`。为了让其`time complexity`达到**线性阶**，考虑**桶排序**、**计数排序**、**基数排序**。

**桶排序**，数据为十万个手机号码，手机号码均不一样，说明数据范围很大，划分桶不好划分，且均匀性不好评价。

**计数排序**，由于数据范围很大，且号码均不相同，所以计数排序不合适。

**基数排序**，每个手机号码`11`位，如果知道第一位大，则后面位不需要比较。因为进行的是位的比较，在比较第二位的时候，为了不打乱第一位已排好的序，所以位排序时使用的算法必须使用**稳定排序算法**。也就是说，因为手机号码`11`位，进行`11`次位的稳定排序后，就排好序了。接着，考虑位排序用哪个算法？为了让时间复杂度尽可能低，所以先考虑线性排序。**位的范围在`0-9`之间，范围很小**，数据量很大，这点计数排序和桶排序都满足，但由于位排序必须稳定，而桶排序不稳定，故选用**计数排序**。最后，对时间复杂度进行分析，每次位排序的时间复杂度为`O(n)`，手机号码一共有`11`位，则时间复杂度为`O(11*n)`，**因此，整个基数排序的时间复杂度为`O(n)`**。

#### 基数排序的补充

对于上面的手机号码排序用的是基数排序，手机号码的位数刚好都是`11`位，但如果数据的位数不相同呢？这是可以用`0`来补充到相同。

### 3.4 思考题

假设我们现在需要对 `D，a，F，B，c，A，z` 这个字符串进行排序，要求将其中所有小写字母都排在大写字母的前面，但小写字母内部和大写字母内部不要求有序。比如经过排序之后为 `a，c，z，D，F，B，A`这个如何来实现呢？如果字符串中存储的不仅有大小写字母，还有数字。要将小写字母的放到前面，大写字母放在最后，数字放在中间，不用排序算法，又该怎么解决呢？

#### 解决方法（两种）

* 第一种，用快排思想，先把第一个字符用临时变量存起来，再定义两个指针，一前一后，先让后移动，如果遇到小写，则与前交换，再让前移动，如果遇到大写，则与后交换。以此循环，直到两个指针相遇

  如果**包含数字**，可以先将**数字与小写**视为同类，先走一遍，再让**小写和数字**走一遍

* 第二种，利用桶排序思想，小写，大写，数字三个桶，遍历一遍，都放进去，然后再从桶中取出来。相当于遍历了两遍，复杂度`O(n)`







