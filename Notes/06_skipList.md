[TOC]

# 为什么 `Redis` 要用跳表来实现有序集合

## 一、什么是跳表

* 数组的插入、删除所需的时间复杂度都为`O(n)`，查找最优为`O(logn)`

* 链表的插入、删除所需的时间复杂度都为`O(1)`，查找为`O(n)`。需要注意的是，链表的插入、删除很多时候都需要先查找到节点的位置，因此也可以理解为：链表的插入、删除整个过程需要`O(n)`。

跳表，是对链表的升级改造，使其插入、删除、查找整个过程均只需要`O(logn)`。

![img](assets/492206afe5e2fef9f683c7cff83afa65.jpg "跳表示例图")

**跳表，就是链表 + 多级索引，上级索引节点由下级每`N`个节点提取一个节点上来构成（上图`N = 2`），索引层节点通过`down`指针指向下级索引，一直到原始链表。**每次查找，都从最顶层索引开始，**根据值的范围**，一直往下到原始链表，例如上图中构建了两级索引，现查找元素`16`，则先从第二级索引，根据值范围，一直到原始链表，经过`6`个节点便可找到。效率比简单的原始链表来查找快。

## 二、跳表有多快

> 这里只分析查找，因为链表的插入跟删除在查找到节点的位置后，只需要`O(1)`，因此跳表的插入跟删除的时间复杂度跟查找时一致的。

如果一个链表有`n`个节点，建立完整索引（即最顶层索引层为两个节点 ==> 最顶层为原始链表），假设每`2`个就提取一个节点来构成上级索引，那么一共就会有多少层索引呢？由下列公式推导
$$
n/2^h = 2
$$
得
$$
h = log_2n - 1
$$
算上原始链表层，即 $$h = log_2n$$，因为算的是最坏时间复杂度，所以考虑最坏情况。由于每`2`个就提取一个节点，那么从对顶层开始，一直到原始链表层，每层最多只需要遍历`3`个节点（**这里需要好好理解一下为什么是`3`个**）。因此，跳表的最坏时间复杂度为 $$O(3*log_2n)$$，即为`O(logn)`

## 三、跳表的空间复杂度

跳表在链表基础上建立多级索引，操作效率大大提高了，但是会不会太过于占用内存空间了呢？

![img](assets/100e9d6e5abeaae542cf7841be3f8255.jpg "跳表的空间复杂度分析")

由上图易得一个等比数列，由等比数列前`n`项和公式 $$S_n = (a_1 - a_nq) / (1 - q)$$ 计算得空间复杂度为 $$O(n - 1)$$，即为`O(n)`，如果是每`3`个节点抽`1`个，则其空间复杂度为 $$O(n/2 - 1/2)$$，为`O(n)`，虽然两者的时间复杂度均为`O(n)`，但后者明显比前者少了一半的内存空间。

虽然跳表占空间，但实际应用中很多时候存储的是一个很大的对象，而索引节点只是几个指向该对象的指针，此时跳表占用的内存空间一般是可以忽略不计的。

## 四、跳表索引的动态更新

> 我们知道跳表的插入与删除是基于跳表的查找的，时间复杂度也都是`O(logn)`，但有一个问题就是：当跳表插入一个元素或者删除一个元素之后，索引是必须进行更新的，否则跳表有可能退化为简单的链表。那么该怎么对跳表的索引进行更新呢？这个过程也叫**维护索引与原始链表的平衡**

红黑树、`AVL`树维护平衡的方式是进行左右旋，而跳表维护平衡的方式则是通过随机函数。

当往跳表中插入一个元素或者删除一个元素的时候，我们会通过事先设定的随机函数进行计算，根据计算结果，在索引层中也插入该元素，或者删除该元素。

目前先了解这个方法，具体如何更新，如何选择随机函数，可另寻时间深入了解。（2019年11月22日18:53:04）

## 五、跳表与红黑树

> 开篇解答：为什么`Redis`要用跳表来实现有序集合？

`Redis`的有序集合需要满足以下几个**核心操作**

* 插入数据
* 删除数据
* 查找数据
* 按照区间查找数据
* 迭代输出有序序列

其中，插入、删除、查找、迭代输出的操作，红黑树和跳表都可以完成，且时间复杂度一致，均为`O(logn)`。但区间查找，跳表的效率则比红黑树更高。

此外，跳表相比红黑树还有其他优点：

* 跳表实现相比红黑树更简单、容易（**虽然也不容易**）
* 跳表可以改变构建策略（**即每`N`个节点抽取`1`个**），有效平衡执行效率和内存消耗。

然而，跳表也无法完全取代红黑树。因为红黑树出现的时间更早些，很多编程语言中的 `Map`类型都是通过红黑树来实现。但是我们在日常业务开发中，并不需要自己费尽去写一个红黑树，可以直接网上`download`一个，而跳表则更多需要自己实现。**很多时候，我们为了代码简单、易读，会更倾向使用跳表**。

## 六、代码实现

详见 https://github.com/jack-053024/algo/tree/master/python/17_skiplist

