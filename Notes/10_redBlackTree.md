[TOC]

# Red Black Tree

> 红黑树是一种平衡二叉查找树，平衡二叉查找树是一种特殊的二叉查找树。

## 一、平衡二叉查找树

> 伸展树`Splay Tree`，树堆`Treap`等也是平衡二叉树，下面我们主要介绍`Red Black Tree`。红黑树是平衡二叉查找树的 ” 明星树 ”。

二叉查找树的插入、删除、查找的最优时间复杂度为`O(logn)`，最坏时间复杂度是`O(n)`。普通的二叉查找树随着动态的插入、删除，结构会发生变化，效率也会发生变化，极端情况下，时间复杂度会退化到最坏。

为了解决二叉查找树因为插入、删除等动态更新而使二叉树结构发生变化，导致性能退化的问题，给二叉查找树引入**平衡**

### 1.1 平衡的概念

**平衡二叉树** 严格的概念为：二叉树中的任意一个节点的左右子树的高度相差不能大于`1`。根据概念，完全二叉树也是平衡二叉树，但非完全二叉树也可能是平衡二叉树。但我们并不需要**死揪**定义，**只要树的整体高度为对数阶（完全二叉树的树高度为 $$log_2n$$），左右子树高度差异不大**就可以了，这样时间复杂度会尽可能保持在最优。

`AVL`树是严格平衡。而红黑树是非严格平衡。

## 二、红黑树的结构

> 符合怎样的要求才被称为红黑树呢？

红黑树，顾名思义，节点中有两类，一类标红色，一类标黑色。

* 根节点是黑色的
* 每个叶子节点都是黑色的，且为`None`，即叶子节点都不放数据（简化代码）
* 任意相邻节点不能同为红色，即红色节点被黑色节点隔开
* 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点

![img](assets/903ee0dcb62bce2f5b47819541f9069a.jpg)

## 三、Analysis of R-B Tree

> 红黑树是**“ 近似平衡 ”**的，平衡等价于性能不退化，近似平衡则等价为性能不会退化得太严重。

二叉查找树很多操作的性能都跟树的高度成正比。我们知道完全二叉树是极其平衡的，其高度为 $$log_2n​$$。所以要证明红黑树是近似平衡的，只需要分析红黑树的高度稳定趋近 $$log_2n​$$ 即可。

1. 先将红黑树中的红色节点拿掉，剩下黑色节点，此时一些节点会失去父节点，则直接将其祖父节点作为父节点，形成**多叉树**，如下，形成了四叉树。

   ![img](assets/7e6ecc308fe44120f30de809822215ed.jpg)

   根据红黑树结构要求：每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点。我们可以从多叉树中取出某些节点，放到叶子节点的位置上，使得多叉树变成完全二叉树。此时，仅包含黑色几点的多叉树高度，必然比具有相同节点数目的完全二叉树的高度要小，所以去掉红色节点的黑树的高度不会超过 $$ log_2n $$ 

2. 再把红色节点加回去

   由于红色节点不能相邻，也就是说，有一个红色节点，至少就会有一个黑色节点。现在黑树的高度不超过 $$ log_2n $$，那加回红色节点，整颗红黑树的高度也不会超过 $$ 2log_2n $$。

总结：红黑树的高度只比高度平衡的 `AVL` 树的高度仅仅大了一倍，在性能上，下降并不多。这样子推导并不是很准确，实际上，红黑树的性能更好。

实际上，红黑树是一种很复杂的数据结构，可以说是最难掌握的数据结构之一。难点在于红黑树的实现，如果需要自己写代码实现，我们一般更倾向于用跳表。

## 思考题

> 为什么明明红黑树的高度比高度平衡的 `AVL` 树大了一倍，其性能还更好呢？

`AVL` 树作为一种严格平衡的二叉查找树，查找、插入、删除的操作效率都非常高，但有利有弊，`AVL` 树为了维护这种高度平衡，需要付出更大的代价，每次插入、删除都需要做调整，耗费时间。相比之下，红黑树是非严格平衡，但又近似平衡，所以不仅操作高效，维护平衡的成本也不会那么高。

> 知道了红黑树跟 `AVL` 树的区别，但平衡二叉查找树还有 `Treap`、`Splay Tree`，为啥工程上会更喜欢用红黑树呢？

伸展树和树堆在绝大多数情况下，操作效率都很高，但无法避免极端情况下时间复杂度的退化。尽管这种退化的概率不大，但对于单次操作敏感的场景来说并不合适。而红黑树各方面都很稳定，更适合于工业级的应用。